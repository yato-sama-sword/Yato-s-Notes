# Linux

## 文件系统

总的来说，借鉴了UNIX文件系统，把一切资源都看作是文件

### 基础

由索引+内容构成

> 索引为inode，存储**元信息**(比如文件块数、文件拥有者、创建时间等等)
> 
> 内容为block，是实际上的文件内容
> 
> **使用stat命令可以查看文件的inode信息**
> 
> ![img](笔记.assets\文件inode信息.124da86c.png?msec=1657797480991)

### 类型

- **普通文件（-）** ： 用于存储信息和数据， Linux 用户可以根据访问权限对普通文件进行查看、更改和删除。比如：图片、声音、PDF、text、视频、源代码等等。
- **目录文件（d，directory file）** ：目录也是文件的一种，用于表示和管理系统中的文件，目录文件中包含一些文件名和子目录名。打开目录事实上就是打开目录文件。
- **符号链接文件（l，symbolic link）** ：保留了指向文件的地址而不是文件本身。
- **字符设备（c，char）** ：用来访问字符设备比如键盘。
- **设备文件（b，block）** ： 用来访问块设备比如硬盘、软盘。
- **管道文件(p,pipe)** : 一种特殊类型的文件，用于进程之间的通信。
- **套接字(s,socket)** ：用于进程间的网络通信，也可以用于本机之间的非网络通信。

### 目录树

![Linux的目录结构](笔记.assets\Linux目录树.5c5a8ebb.png?msec=1657797480992)

- **/bin：** 存放二进制可执行文件(ls、cat、mkdir 等)，常用命令一般都在这里；
- **/etc：** 存放系统管理和配置文件；
- **/home：** 存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是/home/user，可以用~user 表示；
- **/usr ：** 用于存放系统应用程序；
- **/opt：** 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里；
- **/proc：** 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；
- **/root：** 超级用户（系统管理员）的主目录（特权阶级^o^）；
- **/sbin:** 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等；
- **/dev：** 用于存放设备文件；
- **/mnt：** 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；
- **/boot：** 存放用于系统引导时使用的各种文件；
- **/lib ：** 存放着和系统运行相关的库文件 ；
- **/tmp：** 用于存放各种临时文件，是公用的临时文件存储点；
- **/var：** 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；
- **/lost+found：** 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里。

## 基本命令

> 这里是过一遍程序员鱼皮的流程

```shell
ssh 121.5.151.236 // 本地控制台使用ssh命令连接远程服务器
ifconfig // 查看网络设备信息
free -h // 检查内存是否足够
df -lh 检查磁盘内存是否足够
mkdir xxx // 创建目录xxx
cd xxx // 进入目录xxx
git clone xxx // 用git拉代码
ls // 查看当前目录有哪些文件
cat xxx.md // 查看xxx文件的内容
uname -a // 查看系统的版本
yum install // 下载
sudo // 获取管理员权限
which // 查看文件位置
wget // 下载
tar -zxvf // 解压
--help // 获取帮助手册
mvn install // maven构建项目
find -name '*.jar' // 查找以jar结尾的文件
cp // 复制文件到指定目录
nohup // 后台启动程序
jobs // 查看当前执行任务
ps -ef // 查看当前运行进程
ps -ef|grep 'java' // 正则表达式查找运行的java进程
netstat -ntlp // 查看占用端口
curl 端口 // 访问对应端口
tail -n 10 error.log // 查看日志的后十行
vim xxx // 更改文件内容
kill -9 %l // 杀死进程
top // 查看进程状态
vim start.sh // 写个shell脚本，方便启动的时候执行
```

# Git

## 概念

1. Git存储项目随时间改变的快照

![Git 存储项目随时间改变的快照。](笔记.assets\snapshots.png?msec=1657797480993)

2. Git中的绝大多数操作都在本地执行，只需要访问本地文件和资源，**快准狠！**
3. Git的数据在存储前会计算校验和，并以校验和引用，保证数据完整性！
4. Git一般只添加数据，一般来说不删快照就不会丢数据，好！
5. Git的三种状态：已提交、已修改、已暂存

Git有**工作区、暂存区和版本库**的概念

- 工作区：在电脑里能看到的目录
- 暂存区：指存放在`.git`目录下的index文件
- 版本库：工作区内有一个隐藏的`.git`目录，是git的版本库

![img](常用工具.assets/git三种区域.jpg)

从图中可以看到`Head`的概念，即一个指向master分支的游标。在Idea中的Head其实指向的也是master



## 常用命令

### 获取 Git 仓库

有两种取得 Git 项目仓库的方法。

1. 在现有目录中初始化仓库: 进入项目目录运行 `git init` 命令,该命令将创建一个名为 `.git` 的子目录。
2. 从一个服务器克隆一个现有的 Git 仓库: `git clone [url]` 自定义本地仓库的名字: `git clone [url] directoryname`

### 记录每次更新到仓库

1. **检测当前文件状态** : `git status`
2. **提出更改（把它们添加到暂存区**）：`git add filename` (针对特定文件)、`git add *`(所有文件)、`git add *.txt`（支持通配符，所有 .txt 文件）
3. **忽略文件**：`.gitignore` 文件
4. **提交更新:** `git commit -m "代码提交信息"` （每次准备提交前，先用 `git status` 看下，是不是都已暂存起来了， 然后再运行提交命令 `git commit`）
5. **跳过使用暂存区域更新的方式** : `git commit -a -m "代码提交信息"`。 `git commit` 加上 `-a` 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 `git add` 步骤。
6. **移除文件** ：`git rm filename` （从暂存区域移除，然后提交。）
7. **对文件重命名** ：`git mv README.md README`(这个命令相当于`mv README.md README`、`git rm README.md`、`git add README` 这三条命令的集合)

### 一个好的 Git 提交消息

一个好的 Git 提交消息如下：

> 标题行：用这一行来描述和解释你的这次提交
>
> 主体部分可以是很少的几行，来加入更多的细节来解释提交，最好是能给出一些相关的背景或者解释这个提交能修复和解决什么问题。
>
> 主体部分当然也可以有几段，但是一定要注意换行和句子不要太长。因为这样在使用 "git log" 的时候会有缩进比较好看。

提交的标题行描述应该尽量的清晰和尽量的一句话概括。这样就方便相关的 Git 日志查看工具显示和其他人的阅读。

### 推送改动到远程仓库

- 如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：`git remote add origin <server>` ,比如我们要让本地的一个仓库和 Github 上创建的一个仓库关联可以这样`git remote add origin https://github.com/Snailclimb/test.git`

- 将这些改动提交到远端仓库：`git push origin master` (可以把 *master* 换成你想要推送的任何分支)
  
  如此你就能够将你的改动推送到所添加的服务器上去了。

### 远程仓库的移除与重命名

- 将 test 重命名为 test1：`git remote rename test test1`
- 移除远程仓库 test1:`git remote rm test1`

### 查看提交历史

在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 `git log` 命令。`git log` 会按提交时间列出所有的更新，最近的更新排在最上面。

**可以添加一些参数来查看自己希望看到的内容：**

只看某个人的提交记录：

```bash
git log --author=bob
```

### 撤销操作

有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 `--amend` 选项的提交命令尝试重新提交：

```bash
git commit --amend
```

取消暂存的文件

```bash
git reset filename
```

撤消对文件的修改:

```bash
git checkout -- filename
```

假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：

```bash
git fetch origin
git reset --hard origin/master
```

### 分支

分支是用来将特性开发绝缘开来的。在你创建仓库的时候，*master* 是“默认”的分支。在其他分支上进行开发，完成后再将它们合并到主分支上。

我们通常在开发新功能、修复一个紧急 bug 等等时候会选择创建分支。单分支开发好还是多分支开发好，还是要看具体场景来说。

创建一个名字叫做 test 的分支

```bash
git branch test
```

切换当前分支到 test（当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样）

```bash
git checkout test
```

![img](笔记.assets\2019-3切换分支.png?msec=1657797480993)

你也可以直接这样创建分支并切换过去(上面两条命令的合写)

```bash
git checkout -b feature_x
```

切换到主分支

```bash
git checkout master
```

合并分支(可能会有冲突)

```bash
 git merge test
```

把新建的分支删掉

```bash
git branch -d feature_x
```

将分支推送到远端仓库（推送成功后其他人可见）

```bash
git push origin
```

# Docker

## 容器

将软件打包成标准化单元，用于开发、交付和部署。其优点在于：1.容器镜像是轻量的可执行的独立软件包；2.容器化软件适用于基于Linux和Windows的应用，在任何环境中都能始终如一地运行；3.容器赋予软件独立性

相较于虚拟机，容器虚拟化的是操作系统而非软件，容器间共享一套操作系统资源（**换言之就是使用同一个内核**），虚拟机是虚拟出一套硬件，运行完整的操作系统

![img](笔记.assets\4ef8691d67eb1eb53217099d0a691eb5.png?msec=1657797480994)

## 概念

对进程进行封装隔离的，属于操作系统层面的虚拟化技术的，世界领先的软件容器平台。可以自动执行如搭建和配置开发环境的重复性任务，用户可以方便地创建和使用容器，并对容器进行版本管理、复制、分享、修改嘞。重点由三部分组成

1. Image镜像：**Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。**镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。
2. Container容器：**容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等**。其实质是进程，和镜像采用同样的分层存储方式，所以存储要绑定宿主目录或使用数据卷
3. Repository镜像：镜像构建完成后，可以很容易的在当前宿主上运行，但是， **如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。**一般来说docker pull的就是别人的仓库中的镜像

## 优势

1. 提供**除内核外完整的运行时环境，确保了应用运行环境一致性**：意味着更加快速的启动时间
2. 隔离性：避免公用服务器中资源受到其它用户影响的问题
3. 弹性伸缩，快速扩展：善于处理集中爆发的服务器使用压力
4. 迁移方便：可以轻易将一个平台上运行的应用，迁移到另一个平台上，不用担心运行环境的变化导致应用无法正常运行的情况
5. 持续交付和部署：通过定制应用镜像实现持续集成、持续交付、部署

## 总结

总的来说：**Docker** 运行过程也就是去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器。所以，我们也常常将 Docker 称为码头工人或码头装卸工，这和 Docker 的中文翻译搬运工人如出一辙

# FastDFS

## 概念

- Tracker Server：跟踪服务器，主要负责调度storage节点与client通信，在访问上起负载均衡的作用，和记录storage节点的运行状态，是连接client和storage节点的枢纽。

- Storage Server：存储服务器，保存文件和文件的meta data（元数据），每个storage server会启动一个单独的线程主动向Tracker cluster中每个tracker server报告其状态信息，包括磁盘使用情况，文件同步情况及文件上传下载次数统计等信息
- Group：文件组，多台Storage Server的集群。上传一个文件到同组内的一台机器上后，FastDFS会将该文件即时同步到同组内的其它所有机器上，起到备份的作用。不同组的服务器，保存的数据不同，而且相互独立，不进行通信。
- Tracker Cluster：跟踪服务器的集群，有一组Tracker Server（跟踪服务器）组成。

- Storage Cluster ：存储集群，有多个Group组成。

## 上传流程

1. Client通过Tracker server查找可用的Storage server。
2. Tracker server向Client返回一台可用的Storage server的IP地址和端口号。

3. Client直接通过Tracker server返回的IP地址和端口与其中一台Storage server建立连接并进行文件上传。

4. 上传完成，Storage server返回Client一个文件ID，文件上传结束。


## 下载流程

1. Client通过Tracker server查找要下载文件所在的的Storage server。
2. Tracker server向Client返回包含指定文件的某个Storage server的IP地址和端口号。

3. Client直接通过Tracker server返回的IP地址和端口与其中一台Storage server建立连接并指定要下载文件。

4. 下载文件成功。

# 正则表达式

## 简介

**正则表达式**，又称规则表达式**,**（[Regular Expression](https://baike.baidu.com/item/Regular Expression/10670121?fromModule=lemma_inlink)，在代码中常简写为regex、regexp或RE），是一种[文本模式](https://baike.baidu.com/item/文本模式/7355156?fromModule=lemma_inlink)，包括普通字符（例如，a 到 z 之间的字母）和[特殊字符](https://baike.baidu.com/item/特殊字符/112715?fromModule=lemma_inlink)（称为"[元字符](https://baike.baidu.com/item/元字符/6062776?fromModule=lemma_inlink)"），是[计算机科学](https://baike.baidu.com/item/计算机科学/9132?fromModule=lemma_inlink)的一个概念。正则表达式使用单个[字符串](https://baike.baidu.com/item/字符串/1017763?fromModule=lemma_inlink)来描述、匹配一系列匹配某个[句法规则](https://baike.baidu.com/item/句法规则/53352483?fromModule=lemma_inlink)的字符串，通常被用来检索、替换那些符合某个模式（规则）的文本。——百度百科

从个人理解来看，正则表达式要不就是用来过滤某些非法字符串、要不就是去寻找某些特定需要的字符串，起到的作用就是匹配。

## Java.util.regex

主要由以下三个**类组成**

1. Pattern类，正则表达式的编译表示（也许可以理解为模板）
2. Matcher类，对输入字符串进行解释和匹配操作的引擎
3. PatternSyntaxException，非强制异常类，指出正则表达式下的语法错误

**常用语法**如下表所示——菜鸟教程

| 字符        | 说明                                                         |
| :---------- | :----------------------------------------------------------- |
| \           | 将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如， **n**匹配字符 **n**。**\n** 匹配换行符。序列 **\\\\** 匹配 **\\** ，**\\(** 匹配 **(**。 |
| ^           | 匹配输入字符串开始的位置。如果设置了 **RegExp** 对象的 **Multiline** 属性，^ 还会与"\n"或"\r"之后的位置匹配。 |
| $           | 匹配输入字符串结尾的位置。如果设置了 **RegExp** 对象的 **Multiline** 属性，$ 还会与"\n"或"\r"之前的位置匹配。 |
| *           | 零次或多次匹配前面的字符或子表达式。例如，zo* 匹配"z"和"zoo"。* 等效于 {0,}。 |
| +           | 一次或多次匹配前面的字符或子表达式。例如，"zo+"与"zo"和"zoo"匹配，但与"z"不匹配。+ 等效于 {1,}。 |
| ?           | 零次或一次匹配前面的字符或子表达式。例如，"do(es)?"匹配"do"或"does"中的"do"。? 等效于 {0,1}。 |
| {n}         | *n* 是非负整数。正好匹配 *n* 次。例如，"o{2}"与"Bob"中的"o"不匹配，但与"food"中的两个"o"匹配。 |
| {n,}        | *n* 是非负整数。至少匹配 *n* 次。例如，"o{2,}"不匹配"Bob"中的"o"，而匹配"foooood"中的所有 o。"o{1,}"等效于"o+"。"o{0,}"等效于"o*"。 |
| {n,m}       | *m* 和 *n* 是非负整数，其中 *n* <= *m*。匹配至少 *n* 次，至多 *m* 次。例如，"o{1,3}"匹配"fooooood"中的头三个 o。'o{0,1}' 等效于 'o?'。注意：您不能将空格插入逗号和数字之间。 |
| ?           | 当此字符紧随任何其他限定符（*、+、?、{*n*}、{*n*,}、{*n*,*m*}）之后时，匹配模式是"非贪心的"。"非贪心的"模式匹配搜索到的、尽可能短的字符串，而默认的"贪心的"模式匹配搜索到的、尽可能长的字符串。例如，在字符串"oooo"中，"o+?"只匹配单个"o"，而"o+"匹配所有"o"。 |
| .           | 匹配除"\r\n"之外的任何单个字符。若要匹配包括"\r\n"在内的任意字符，请使用诸如"[\s\S]"之类的模式。 |
| (pattern)   | 匹配 *pattern* 并捕获该匹配的子表达式。可以使用 **$0…$9** 属性从结果"匹配"集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用"\("或者"\)"。 |
| (?:pattern) | 匹配 *pattern* 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用"or"字符 (\|) 组合模式部件的情况很有用。例如，'industr(?:y\|ies) 是比 'industry\|industries' 更经济的表达式。 |
| (?=pattern) | 执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 *pattern* 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows (?=95\|98\|NT\|2000)' 匹配"Windows 2000"中的"Windows"，但不匹配"Windows 3.1"中的"Windows"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 |
| (?!pattern) | 执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 *pattern* 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows (?!95\|98\|NT\|2000)' 匹配"Windows 3.1"中的 "Windows"，但不匹配"Windows 2000"中的"Windows"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 |
| x\|y        | 匹配 *x* 或 *y*。例如，'z\|food' 匹配"z"或"food"。'(z\|f)ood' 匹配"zood"或"food"。 |
| [xyz]       | 字符集。匹配包含的任一字符。例如，"[abc]"匹配"plain"中的"a"。 |
| [^xyz]      | 反向字符集。匹配未包含的任何字符。例如，"[^abc]"匹配"plain"中"p"，"l"，"i"，"n"。 |
| [a-z]       | 字符范围。匹配指定范围内的任何字符。例如，"[a-z]"匹配"a"到"z"范围内的任何小写字母。 |
| [^a-z]      | 反向范围字符。匹配不在指定的范围内的任何字符。例如，"[^a-z]"匹配任何不在"a"到"z"范围内的任何字符。 |
| \b          | 匹配一个字边界，即字与空格间的位置。例如，"er\b"匹配"never"中的"er"，但不匹配"verb"中的"er"。 |
| \B          | 非字边界匹配。"er\B"匹配"verb"中的"er"，但不匹配"never"中的"er"。 |
| \cx         | 匹配 *x* 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。*x* 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是"c"字符本身。 |
| \d          | 数字字符匹配。等效于 [0-9]。                                 |
| \D          | 非数字字符匹配。等效于 [^0-9]。                              |
| \f          | 换页符匹配。等效于 \x0c 和 \cL。                             |
| \n          | 换行符匹配。等效于 \x0a 和 \cJ。                             |
| \r          | 匹配一个回车符。等效于 \x0d 和 \cM。                         |
| \s          | 匹配任何空白字符，包括空格、制表符、换页符等。与 [\f\n\r\t\v] 等效。 |
| \S          | 匹配任何非空白字符。与 [ ^\f\n\r\t\v ] 等效。                |
| \t          | 制表符匹配。与 \x09 和 \cI 等效。                            |
| \v          | 垂直制表符匹配。与 \x0b 和 \cK 等效。                        |
| \w          | 匹配任何字类字符，包括下划线。与"[ A-Za-z0-9_ ]"等效。       |
| \W          | 与任何非单词字符匹配。与"[ ^A-Za-z0-9_ ]"等效。              |
| \xn         | 匹配 *n*，此处的 *n* 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，"\x41"匹配"A"。"\x041"与"\x04"&"1"等效。允许在正则表达式中使用 ASCII 代码。 |
| \num        | 匹配 *num*，此处的 *num* 是一个正整数。到捕获匹配的反向引用。例如，"(.)\1"匹配两个连续的相同字符。 |
| \n          | 标识一个八进制转义码或反向引用。如果 \n 前面至少有 *n* 个捕获子表达式，那么 *n* 是反向引用。否则，如果 *n* 是八进制数 (0-7)，那么 *n* 是八进制转义码。 |
| \nm         | 标识一个八进制转义码或反向引用。如果 \*nm* 前面至少有 *nm* 个捕获子表达式，那么 *nm* 是反向引用。如果 \nm 前面至少有 *n* 个捕获，则 *n* 是反向引用，后面跟有字符 *m*。如果两种前面的情况都不存在，则 \nm 匹配八进制值 *nm*，其中 *n* 和 *m* 是八进制数字 (0-7)。 |
| \nml        | 当 *n* 是八进制数 (0-3)，*m* 和 *l* 是八进制数 (0-7) 时，匹配八进制转义码 nml。 |
| \un         | 匹配 *n*，其中 *n* 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。 |

以下面的正则表达式为例

```
[^/]+(?!.*/)
```

