# 环境配置步骤

## docker配置

所有环境配置都通过docker进行安装

> 一些注意事项
> 
> 1. rabbitmq需要设置用户和密码才能访问
> 2. elk中需要安装ik分词器，可以通过docker映射或者说链接到外部文件夹，实现对容器内配置的更改
> 3. fastfdfs要从浏览器访问需要实现nginx代理

# 后端开发思路流程

## 整体框架

Spring Cloud框架实现，整体可以分为后台管理和前台门户两个部分

> 后台系统主要功能：

- 商品管理，包括商品分类，品牌，商品规格等信息的管理


> 前台门户主要功能：

- 搜索商品

- 加入购物车

- 下单

- 等等

## 模块设计/实现

### 1 网关微服务

#### 实现思路

![img](https://img-blog.csdnimg.cn/20181214102311483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5ajIwMThneXE=,size_16,color_FFFFFF,t_70)

不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。

> 为什么要有服务网关：

服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。

> 主要功能：

- 过滤：拦截所有路径后放行一部分路径
- 路由：直接对服务进行路径映射

#### 部分功能展示

zuulFilter实现放行网址和跨域功能

```java
package com.foxmall.gateway.filter;


import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.exception.ZuulException;
import com.foxmall.gateway.config.FilterProperties;
import com.foxmall.gateway.config.JwtProperties;
import com.foxmall.common.utils.CookieUtils;
import com.foxmall.auth.utils.JwtUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;
import java.util.Arrays;
import java.util.List;


/**
 * zuul自定义的filter
 * @author yato
 */
@Component
public class LoginFilter extends ZuulFilter {

    @Autowired
    private JwtProperties properties;

    /**
     * 放行路径
     */
    @Autowired
    private FilterProperties filterProperties;

    private static final Logger logger = LoggerFactory.getLogger(LoginFilter.class);

    /**
     * 过滤器在请求被路由调用之前调用
     * @return 设置为PRE类型
     */
    @Override
    public String filterType() {
        return "pre";
    }

    @Override
    public int filterOrder() {
        return 5;
    }

    @Override
    public boolean shouldFilter() {
        //1.获取上下文
        RequestContext context = RequestContext.getCurrentContext();
        //2.获取request
        HttpServletRequest request = context.getRequest();
        //3.获取路径
        String requestUri = request.getRequestURI();
        logger.info(requestUri);
        //4.判断白名单
        return !isAllowPath(requestUri);
    }

    private boolean isAllowPath(String requestUri) {
        //1.定义一个标记
        boolean flag = false;

        //2.遍历允许访问的路径
        List<String> paths = Arrays.asList(this.filterProperties.getAllowPaths().split(" "));
        for (String path : paths){
            if (requestUri.startsWith(path)){
                flag = true;
                break;
            }
        }
        return flag;
    }

    @Override
    public Object run() throws ZuulException {
        //1.获取上下文
        RequestContext context = RequestContext.getCurrentContext();
        //2.获取request
        HttpServletRequest request = context.getRequest();
        //3.获取token
        String token = CookieUtils.getCookieValue(request,this.properties.getCookieName());
        //4.校验
        try{
            //4.1 校验通过就放行
            JwtUtils.getInfoFromToken(token,this.properties.getPublicKey());
        }catch (Exception e){
            //4.2 校验不通过，返回403
            context.setSendZuulResponse(false);
            context.setResponseStatusCode(HttpStatus.FORBIDDEN.value());
        }
        return null;
    }
}
```

### 2 授权中心微服务

#### 实现思路

> 结合RSA的鉴权

![img](https://img-blog.csdnimg.cn/20181214104033784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5ajIwMThneXE=,size_16,color_FFFFFF,t_70)

- 首先利用RSA生成公钥和私钥。私钥保存在授权中心，公钥保存在Zuul和各个微服务
- 用户请求登录
- 授权中心校验，通过后用私钥对JWT进行签名加密
- 返回jwt给用户
- 用户携带JWT访问
- Zuul直接通过公钥解密JWT，进行验证，验证通过则放行
- 请求到达微服务，微服务直接用公钥解析JWT，获取用户信息，无需访问授权中心

> 授权中心的主要职责

1. 用户鉴权：接收用户的登录请求，通过用户中心的接口进行校验，通过后生成JWT。使用私钥生成JWT并返回
2. 服务鉴权：微服务间的调用不经过Zuul，会有风险，需要鉴权中心进行认证。原理与用户鉴权类似，但逻辑稍微复杂一些（未实现）

#### 部分功能展示

用户鉴权功能：总的流程是对jwt(token)进行解析，并获取token重点信息。具体来说采用rsa加解密的形式，使用私钥加密。以登录授权为例，首先需要在数据库中查询是否存在当前用户，如果有，会向redis中生成一个载荷数据为userinfo，密钥要通过配置文件中给定的私钥地址去获取，过期时间为配置文件中给定时间

```java
public ResponseEntity<Void> authentication(
            @RequestParam("username") String username,
            @RequestParam("password") String password,
            HttpServletRequest request,
            HttpServletResponse response
    ){
        //1.登录校验
        String token = this.authService.authentication(username,password);
        if (StringUtils.isBlank(token)){
            return new ResponseEntity<>(HttpStatus.UNAUTHORIZED);
        }
        //2.将token写入cookie，并指定httpOnly为true，防止通过js获取和修改
        CookieUtils.setCookie(request,response,properties.getCookieName(),token,properties.getCookieMaxAge(),true);

        return ResponseEntity.ok().build();
    }
```

```java
public String authentication(String username, String password) {
        try{
            //1.查询用户信息
            User user = this.userClient.queryUser(username,password);
            //2.查询结果为空，则直接返回null
            if (user == null){
                return null;
            }
            //3.查询结果不为空，则生成token
            return JwtUtils.generateToken(new UserInfo(user.getId(), user.getUsername()),
                    properties.getPrivateKey(), properties.getExpire());

        }catch (Exception e){
            e.printStackTrace();
            return null;
        }
    }
```

```java
public static String generateToken(UserInfo userInfo, PrivateKey privateKey, int expireMinutes) throws Exception {
    return Jwts.builder()
            .claim(JwtConstans.JWT_KEY_ID, userInfo.getId())
            .claim(JwtConstans.JWT_KEY_USER_NAME, userInfo.getUsername())
            .setExpiration(DateTime.now().plusDays(expireMinutes).toDate())
            .signWith(SignatureAlgorithm.RS256, privateKey)
            .compact();
}
```

### 3 购物车微服务

#### 实现思路

> 购物车功能

- 用户可以在登录状态下将商品添加到购物车（放入redis）
- 用户可以在未登录状态下将商品添加到购物车（放入localstorage）
- 用户可以使用购物车一起结算下单
- 用户可以查询自己的购物车
- 用户可以在购物车中修改购买商品的数量
- 用户可以在购物车中删除商品
- 在购物车中展示商品优惠信息
- 提示购物车商品价格变化

> **逻辑判断**

新增商品：

​    判断是否登录   

​        是：则添加商品到后台Redis中

​        否：则添加商品到本地的Localstorage

查询购物车

​    判断是否登录

​        否：直接查询localstorage中数据并展示

​        是：已登录，则需要先看本地是否有数据，

​            有：需要提交到后台添加到redis，合并数据，而后查询

​            否：直接去后台查询redis，而后返回

#### 部分功能展示

**添加购物车：**

如果当前线程中存在用户，则会调用以下方法。当前线程指的是ThreadLocal，使用threadlocal存储用户信息的好处在于，用户信息在一次请求中使用，后续就没有继续使用的必要了，threadlocal在请求结束后就可以销毁。并且由于threadlocal只能在线程内使用，也提高了安全性

```java
public void addCart(Cart cart) {
    //1.从threadlocal中获取用户
    UserInfo userInfo = LoginInterceptor.getLoginUser();
    //2.Redis的key
    String key = KEY_PREFIX + userInfo.getId();
    //3.获取hash操作对象
    BoundHashOperations<String,Object,Object> hashOperations = this.stringRedisTemplate.boundHashOps(key);
    //4.查询是否存在
    Long skuId = cart.getSkuId();
    Integer num = cart.getNum();
    Boolean result = hashOperations.hasKey(skuId.toString());
    if (Boolean.TRUE.equals(result)){
        //5.存在，获取购物车数据
        String json = hashOperations.get(skuId.toString()).toString();
        cart = JsonUtils.parse(json, Cart.class);
        //6.修改购物车数量
        cart.setNum(cart.getNum() + num);
    }else{
        //7.不存在，新增购物车数据
        cart.setUserId(userInfo.getId());
        //8.其他商品信息，需要查询商品微服务
        Sku sku = this.goodsClient.querySkuById(skuId);
        cart.setImage(StringUtils.isBlank(sku.getImages()) ? "" : StringUtils.split(sku.getImages(),",")[0]);
        cart.setPrice(sku.getPrice());
        cart.setTitle(sku.getTitle());
        cart.setOwnSpec(sku.getOwnSpec());
    }
    //9.将购物车数据写入redis
    hashOperations.put(cart.getSkuId().toString(),JsonUtils.serialize(cart));
}
```

### 4 评论微服务

#### 实现思路

> 功能需求

1. 评论的增删改查
2. 评论点赞

评论和搜索模块的数据需要根据mysql数据库中进行相应改变，这一点用到rabbitMq

> 设计思路

首先是表的结构设计(在Mongodb中叫做Collection)如下：

| 字段名称    | 字段类型 | 字段意义                                           |
| ----------- | -------- | -------------------------------------------------- |
| _id         | 文本     | 类似于MySql主键                                    |
| Orderid     | 文本     | 订单id                                             |
| Spuid       | 文本     | 商品id                                             |
| Userid      | 文本     | 用户id                                             |
| Nickname    | 文本     | 评论人昵称                                         |
| Parentid    | 文本     | 父评论id，顶级评论为0                              |
| Isparent    | 布尔型   | 是否是顶级评论                                     |
| Publishtime | 日期     | 评论日期                                           |
| Visits      | 整型     | 访问量                                             |
| Thumbup     | 整型     | 点赞数                                             |
| Images      | 数组     | 图片，由于可能有很多张，所以采用数组的形式进行存储 |
| Content     | 文本     | 评论内容                                           |
| Comment     | 整型     | 回复数                                             |
| Iscomment   | 布尔型   | 是否允许回复                                       |
| Type        | 整型     | 评价类型 1-5打分                                   |

#### 部分功能展示

> 使用MongoRepositry和mongoTemplate实现新增评论功能
>
> 解释下相关概念
>
> 1. MongoTemplate
>
> 	1. 基本方法
>
> 		mongoTemplate.findAll(Student.class)`: 查询Student文档的全部数据`
>
> 		mongoTemplate.findById(<id>, Student.class)`: 查询Student文档id为id的数据
> 		 `
>
> 		mongoTemplate.find(query, Student.class);`: 根据query内的查询条件查询`
>
> 		mongoTemplate.upsert(query, update, Student.class)`: 修改
> 		 `mongoTemplate.remove(query, Student.class)`: 删除
> 		 `mongoTemplate.insert(student)`: 新增`
>
> 	2. 基础概念
>
> 		1. Query：封装条件对象，提供查询接口；
>
> 			Criteria：条件对象，可以设置给定的条件
>
> 		2. **精准条件**：criteria.and(“key”).is(“条件”)
>
> 			**模糊条件**：criteria.and(“key”).regex(“条件”)
>
> 			**封装条件**：query.addCriteria(criteria)
>
> 			**大于**（创建新的criteria）：Criteria gt = Criteria.where(“key”).gt（“条件”）
>
> 			**小于**（创建新的criteria）：Criteria lt = Criteria.where(“key”).lt（“条件”）
>
> 			Query.addCriteria(new Criteria().andOperator(gt,lt))`一个query中只能有一个andOperator(),参数也可以是Criteria数组`
>
> 			**排序** ：query.with（new Sort(Sort.Direction.ASC, "age"). and(new Sort(Sort.Direction.DESC, "date")))
>
> 2. MongoRepositry(个人感觉比较适用于没有参数的时候)
>
> 	1. 基本方法
> 		1. count（）统计总数
> 		2. count（Example< S > example）条件统计总数
> 		3. delete（T entities）通过对象信息删除某条数据
> 		4. deleteById（ID id）通过id删除某条数据
> 		5. deleteALL（Iterable<? **extends** **T**> entities）批量删除某条数据
> 		6. deleteAll（) 清空表中所有的数据
> 		7. existsById（ID id) 判断数据是否存在
> 		8. exists（Example< T > example) 判断某特定数据是否存在
> 		9. findAll（) 获取表中所有的数据
> 		10. findAll（Sort sort) 获取表中所有的数据，按照某特定字段排序
> 		11. findAll（Pageable pageAble) 获取表中所有的数据,分页查询
> 		12. findAll（Example< T > example) 条件查询
> 		13. findAll（Iterable ids) 条件查询
> 		14. findAll（Example< T > example,Pageable pageable) 条件分页查询
> 		15. findAll（Example< T > example,Sort sort) 条件查询排序
> 		16. findOneById（ID id) 通过id查询一条数据
> 		17. findOne（Example example) 通过条件查询一条数据
> 		18. insert(S entities) 插入一条数据
> 		19. insert(Iterable< T > entities) 插入多条数据
> 		20. save(S entities) 保存一条数据
> 		21. saveAll(Iterable< T > entities)
> 	2. 基础概念
> 		1. Example：在tk.mybatis中也介绍过，其实是一种规范，是可以自定义查询条件的对象
> 		2. PageAble：表示查询结果是分页的，是一个可实现的接口

```java
public boolean add(Long orderId, Review review) {
    //1.检查用户是否在该商品下发表过顶级评论过
    if (Boolean.TRUE.equals(review.getIsparent())) {
        Query queryTop = new Query();
        queryTop.addCriteria(Criteria.where("userid").is(review.getUserid()));
        queryTop.addCriteria(Criteria.where("orderid").is(review.getOrderid()));
        queryTop.addCriteria(Criteria.where("spuid").is(review.getSpuid()));
        List<Review> old = this.mongoTemplate.find(queryTop, Review.class);
        if (!old.isEmpty() && Boolean.TRUE.equals(old.get(0).getIsparent())) {
            return false;
        }
    }
    //2.修改订单状态,6代表评价状态
    boolean result = Boolean.TRUE.equals(this.orderClient.updateOrderStatus(orderId, 6).getBody());
    if (!result){
        return false;
    }
    //3.添加评论
    /**
     * 设置主键
     */
    review.set_id(idWorker.nextId() + "");
    review.setPublishtime(new Date());
    review.setComment(0);
    review.setThumbup(0);
    review.setVisits(0);
    if (review.getParentid() != null && !"".equals(review.getParentid())){
        //如果存在上级id，则上级评论数加1，将上级评论的isParent设置为true，浏览量加一
        Query query = new Query();
        query.addCriteria(Criteria.where("_id").is(review.getParentid()));
        Update update = new Update();
        update.inc("comment",1);
        update.set("isparent",true);
        update.inc("visits",1);
        this.mongoTemplate.updateFirst(query,update,"review");
    }
    commentDao.save(review);
    return true;
}
```

### 5 配置中心微服务

#### 实现思路

在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。

使用SpringCloud Bus来实现配置的自动更新。

> 组成结构

在spring cloud config 组件中，分两个角色，一是config server，二是config client。

Config Server是一个可横向扩展、集中式的配置服务器，它用于集中管理应用程序各个环境下的配置，默认使用Git存储配置文件内容，也可以使用SVN存储，或者是本地文件存存储

Config Client是Config Server的客户端，用于操作存储在Config Server中的配置内容。微服务在启动时会请求Config Server获取配置文件的内容，请求到后再启动容器

> 实现过程

创建配置中心，对Config Server进行配置，然后在其它微服务中配置Config Client。最后使用Github上的Webhooks进行配置的动态刷新，所以还要使用内网穿透工具，同时要在配置中心中添加过滤器，因为使用Webhooks提交请求时会加上一段Payload，而本地是无法解析这个Payload的，所以要将它过滤掉。

#### 部分功能展示

下面是配置文件(主要实现功能就通过配置文件了)

```yml
server:
  port: 10011
spring:
  application:
    name: config-service
  cloud:
    config:
      server:
        git:
          uri: https://github.com/yato-sama-sword/emp-config.git
    # 开启消息跟踪
    bus:
      enabled: true
      trace:
        enabled: true

  rabbitmq:
    host: 124.222.45.111
    username: guest
    password: guest
    virtual-host: /emp

# 暴露触发消息总线的地址
management:
  endpoints:
    web:
      exposure:
        include: bus-refresh
```

过滤payload信息

```java
@Override
public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
    HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;
    HttpServletResponse httpServletResponse = (HttpServletResponse) servletResponse;
    String url = httpServletRequest.getRequestURI();

    //过滤/actuator/bus-refresh请求
    String suffix = "/bus-refresh";
    if (!url.endsWith(suffix)){
        filterChain.doFilter(servletRequest,servletResponse);
        return;
    }

    MyRequestWrapper requestWrapper = new MyRequestWrapper(httpServletRequest);
    filterChain.doFilter(requestWrapper,servletResponse);

}
```

### 6 页面详情微服务

#### 实现思路

>(未完整实现)

商品详情浏览量比较大，并发高，所以单独开启一个微服务用来展示商品详情，并且对其进行静态化处理，保存为静态html文件。在用户访问商品详情页面时，让nginx对商品请求进行监听，指向本地静态页面，如果本地没找到，才反向代理到页面详情微服务端口。

#### 部分功能展示

这里的html变量是存在redis中的静态html文件路径，通过thymeleaf对模板进行渲染生成静态html

```java
public String toItemPage(HttpServletRequest request, HttpServletResponse response, Model model, @PathVariable("id")String id) throws InterruptedException, ExecutionException {
    Long idN = Long.parseLong(id);
    //加载数据
    Map<String, Object> modelMap = this.goodsService.loadModel(idN);
    //把数据放入模型中
    model.addAllAttributes(modelMap);
    //页面静态化
    BoundHashOperations<String,Object,Object> hashOperations = this.stringRedisTemplate.boundHashOps(KEY_PREFIX+id);
    String html = (String) hashOperations.get(id);
    // 先取缓存
     
    if (StringUtils.isNotEmpty(html)){
        //不空，则返回
        return html;
    }
    //手动渲染模板
    Context context = new Context(request.getLocale(), model.asMap());
    html = thymeleafViewResolver.getTemplateEngine().process("item",context);
    if (StringUtils.isNotEmpty(html)){
        //不空，放入缓存
        //设置有效期60秒
        hashOperations.put(id,html);
        hashOperations.expire(60, TimeUnit.SECONDS);
    }
    return html;
}
```

这里通过countDownLatch配合线程池同时处理多个任务，帅！

```java
ExecutorService executorService = ThreadUtils.getEs();

final CountDownLatch countDownLatch = new CountDownLatch(2);

SpuBo spuBo = executorService.submit(() -> {
    countDownLatch.countDown();
    return this.goodsClient.queryGoodsById(spuId);
}).get();

Brand brand = executorService.submit(() -> {
    countDownLatch.countDown();
    return this.brandClient.queryBrandByIds(Collections.singletonList(spuBo.getBrandId())).get(0);
}).get();

countDownLatch.await();

SpuDetail spuDetail = spuBo.getSpuDetail();
List<Sku> skuList = spuBo.getSkus();
List<Long> ids = new ArrayList<>();
ids.add(spuBo.getCid1());
ids.add(spuBo.getCid2());
ids.add(spuBo.getCid3());

List<Category> categoryList = executorService.submit(() -> this.categoryClient.queryCategoryByIds(ids).getBody()).get();
/**
 * 对于规格属性的处理需要注意以下几点：
 *      1. 所有规格都保存为id和name形式
 *      2. 规格对应的值保存为id和value形式
 *      3. 都是map形式
 *      4. 将特有规格参数单独抽取
 */

//获取所有规格参数，然后封装成为id和name形式的数据
String allSpecJson = spuDetail.getSpecifications();
List<Map<String,Object>> allSpecs = JsonUtils.nativeRead(allSpecJson, new TypeReference<List<Map<String, Object>>>() {
});
Map<Integer,String> specName = new HashMap<>();
Map<Integer,Object> specValue = new HashMap<>();
this.getAllSpecifications(allSpecs,specName,specValue);


//获取特有规格参数
String specTJson = spuDetail.getSpecTemplate();
Map<String,String[]> specs = JsonUtils.nativeRead(specTJson, new TypeReference<Map<String, String[]>>() {
});
Map<Integer,String> specialParamName = new HashMap<>();
Map<Integer,String[]> specialParamValue = new HashMap<>();
this.getSpecialSpec(specs,specName,specValue,specialParamName,specialParamValue);

//按照组构造规格参数
List<Map<String,Object>> groups = this.getGroupsSpec(allSpecs,specName,specValue);



Map<String,Object> map = new HashMap<>();
map.put("spu",spuBo);
map.put("spuDetail",spuDetail);
map.put("skus",skuList);
map.put("brand",brand);
map.put("categories",categoryList);
map.put("specName",specName);
map.put("specValue",specValue);
map.put("groups",groups);
map.put("specialParamName",specialParamName);
map.put("specialParamValue",specialParamValue);

return map;
```

### 7 后台管理(item)微服务

#### 实现思路

主要是对商品分类、品牌、商品的规格参数以及商品的CRUD，为后台管理提供各种接口

#### 部分功能展示

因为数据是在mysql数据库更新的，es、mongodb中并没有实时更新，所以需要通过rabbitmq向评论和秒杀微服务发送通知，提示他们更新数据

```java
public void sendMessage(Long id, String type) {
    try {
        this.amqpTemplate.convertAndSend("item." + type, id);
    } catch (Exception e) {
        LOGGER.error("{}商品消息发送异常，商品id：{}", type, id, e);
    }
}
```

### 8 订单微服务

#### 实现思路

> 主体功能：

- 创建订单
- 查询订单
- 更新订单状态
- 根据订单号生成微信付款链接
- 根据订单号查询支付状态

**注意**：如何去保证支付操作的幂等性

#### 部分功能展示

在threadlocal中存放登录用户信息，第一实现了资源的共享，可以在线程内的其他地方使用用户信息而不必从缓存中重新获取，这刚好与一次请求的过程对应。第二更加安全，别的线程无法获取到已登录的用户信息

```java
private JwtProperties jwtProperties;

/**
 * 定义一个线程域，存放登录用户
 */
private static final ThreadLocal<UserInfo> t1 = new ThreadLocal<>();

public LoginInterceptor(JwtProperties jwtProperties) {
    this.jwtProperties = jwtProperties;
}

/**
 * 在业务处理器处理请求之前被调用
 * 如果返回false
 *      则从当前的拦截器往回执行所有拦截器的afterCompletion(),再退出拦截器链
 * 如果返回true
 *      执行下一个拦截器，直到所有拦截器都执行完毕
 *      再执行被拦截的Controller
 *      然后进入拦截器链
 *      从最后一个拦截器往回执行所有的postHandle()
 * @param request
 * @param response
 * @param handler
 * @return
 * @throws Exception
 */
@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    //1.查询token
    String token = CookieUtils.getCookieValue(request,jwtProperties.getCookieName());
    if (StringUtils.isBlank(token)){
        //2.未登录，返回401
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        return false;
    }
    //3.有token，查询用户信息
    try{
        //4.解析成功，说明已经登录
        UserInfo userInfo = JwtUtils.getInfoFromToken(token,jwtProperties.getPublicKey());
        //5.放入线程域
        t1.set(userInfo);
        return true;
    }catch (Exception e){
        //6.抛出异常，证明未登录，返回401
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        return false;
    }
}

/**
 * 在业务处理器处理请求执行完成后，生成视图之前执行的动作
 * 可在modelAndView中加入数据，比如当前时间
 * @param request
 * @param response
 * @param handler
 * @param modelAndView
 * @throws Exception
 */
@Override
public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
    super.postHandle(request, response, handler, modelAndView);
}

/**
 * 在DispatcherServlet完全处理完请求后被调用,可用于清理资源等
 * 当有拦截器抛出异常时,会从当前拦截器往回执行所有的拦截器的afterCompletion()
 * @param request
 * @param response
 * @param handler
 * @param ex
 * @throws Exception
 */
@Override
public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
   t1.remove();
}

public static UserInfo getLoginUser(){
    return t1.get();
}
```

### 9 注册中心微服务

#### 实现思路

> 基本架构

![img](https://img-blog.csdnimg.cn/2018121514422783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5ajIwMThneXE=,size_16,color_FFFFFF,t_70)

Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址

- 提供者：启动后向Eureka注册自己信息（地址，提供什么服务）
- 消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新
- 心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态

#### 部分功能展示

介绍下相关参数，ribbon是eureka内置的负载均衡器，相较于nginx有所不同。hystrix提供熔断功能，zuul网关实现限流路由相关操作

```yml
server:
  port: 10086
spring:
  application:
    name: emp-registry
  rabbitmq:
    host: 124.222.45.111
    username: guest
    password: guest
    virtual-host: /emp
eureka:
  client:
    fetch-registry: false
    register-with-eureka: false
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka
  server:
    enable-self-preservation: false  #关闭自我保护
    eviction-interval-timer-in-ms: 5000 #每隔5秒进行一次服务列表清理

ribbon:
  ConnectTimeout: 4000 # 连接超时时间(ms)
  ReadTimeout: 2000 # 通信超时时间(ms)
  OkToRetryOnAllOperations: true # 是否对所有操作重试
  MaxAutoRetriesNextServer: 1 # 同一服务不同实例的重试次数
  MaxAutoRetries: 1 # 同一实例的重试次数
hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMillisecond: 10000 # 熔断超时时长：10000ms
```

### 10 搜索微服务

#### 实现思路

最最最最核心的方法！就是实现商品搜索功能

#### 部分功能展示

SearchRequest是封装好的搜索参数，包含有搜索条件、当前页、排序字段等属性。search是具体的搜索方法，通过elasticSearch实现

```java
public ResponseEntity<PageResult<Goods>> search(@RequestBody SearchRequest searchRequest){
    SearchResult<Goods> result = this.searchService.search(searchRequest);
    if (result == null){
        return new ResponseEntity<>(HttpStatus.NOT_FOUND);
    } else {
        return ResponseEntity.ok(result);
    }
}
```

### 11 秒杀微服务

#### 实现思路

> 整体思路：先将秒杀商品数据存至redis中，待秒杀操作完成后，通过发送消息至rabbitMq通知订单微服务更新数据库中的库存，cool！
>
> 实现高并发的思路：提前将秒杀商品数据存放至redis中
>
> 解决超卖问题的思路：使用redis的原子操作
>
> 解决少卖问题的思路：不断重试发送信息过程，直至成功

主要接口如下：

- 添加参加秒杀的商品
- 查询秒杀商品
- 创建秒杀地址
- 验证秒杀地址
- 秒杀

> 可优化项

1. 秒杀微服务向订单微服务发送消息失败的重试策略
2. 加入验证码或限购功能避免恶意刷单(会有点影响用户体验)
3. 可以将大量涌入的请求放进消息队列中进行流量削峰

#### 部分功能展示

原子操作redis实现库存更新，解决超卖问题

```java
//1.验证路径
boolean check = this.seckillService.checkSeckillPath(seckillGoods.getId(),userInfo.getId(),path);
if (!check){
    return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
}

//2.内存标记，减少redis访问
boolean over = localOverMap.get(seckillGoods.getSkuId());
if (over){
    return ResponseEntity.ok(result);
}

//3.读取库存，减一后更新缓存
BoundHashOperations<String,Object,Object> hashOperations = this.stringRedisTemplate.boundHashOps(KEY_PREFIX);
// 这里使用redis的原子操作
Long stock = hashOperations.increment(seckillGoods.getSkuId().toString(), -1);

//4.库存不足直接返回
if (stock < 0){
    localOverMap.put(seckillGoods.getSkuId(),true);
    return ResponseEntity.ok(result);
}

//5.库存充足，请求入队
//5.1 获取用户信息
SeckillMessage seckillMessage = new SeckillMessage(userInfo,seckillGoods);
//5.2 发送消息
this.seckillService.sendMessage(seckillMessage);

return ResponseEntity.ok(result);
```

实现不断向订单微服务发送库存更新信息，解决少卖问题

```java
public void sendMessage(SeckillMessage seckillMessage) {
    String json = JsonUtils.serialize(seckillMessage);
    // 不断重试，保证信息可以发送至队列中
    while(true) {
        try {
            this.amqpTemplate.convertAndSend("order.seckill", json);
            return;
        }catch (Exception e){
            LOGGER.error("秒杀商品消息发送异常，商品id：{}",seckillMessage.getSeckillGoods().getSkuId(),e);
        }
    }
}
```

### 12 短信微服务

#### 实现思路

(由于申请阿里短信服务签名必须要企业，所以实际上该功能无法使用)

短信服务监听MQ消息，收到消息后发送短信。其它服务要发送短信时，通过MQ通知短信微服务。

#### 部分功能展示

其他服务发送消息至方法监听的消息队列时，做出响应，发送短信

```java
@RabbitListener(bindings = @QueueBinding(
            value = @Queue(value = "emp.sms.queue",durable = "true"),
            exchange = @Exchange(value = "emp.sms.exchange",ignoreDeclarationExceptions = "true"),
            key = {"sms.verify.code"}
    ))
public void listenSms(Map<String,String> msg){
    if (msg == null || msg.size() <= 0){
        //不做处理
        return;
    }
    String phone = msg.get("phone");
    String code = msg.get("code");

    if (StringUtils.isNotBlank(phone) && StringUtils.isNotBlank(code)){
        //发送消息
        try {
            this.smsUtils.sendSms(phone, code, smsProperties.getSignName(), smsProperties.getVerifyCodeTemplate());
        } catch (ClientException e) {
            throw new RuntimeException(e);
        }
    }
}
```

### 13 文件上传微服务

#### 实现思路

使用分布式文件系统FastDFS实现图片上传。

#### 部分功能展示

使用storgaeClient实现图片文件的上传，支持jpg、jpeg、png

```java
public String upload(MultipartFile file) {
    try {
        // 校验文件类型
        String type = file.getContentType();
        if (!suffixes.contains(type)) {
            logger.info("上传文件失败，文件类型不匹配：{}", type);
            return null;
        }
        // 校验图片内容
        BufferedImage image = ImageIO.read(file.getInputStream());
        if (image == null) {
            logger.info("上传失败，文件内容不符合要求");
            return null;
        }
        // 保存图片，并生成保存路径
        StorePath storePath = this.storageClient.uploadFile(
              file.getInputStream(), file.getSize(), getExtension(file.getOriginalFilename()), null);
        // 此处为ningx代理地址，实为http://124.222.45.111:8888/
        return "http://image.foxmall.com/" + storePath.getFullPath();
    }catch (Exception e){
        return null;
    }
}
```

### 14 用户中心微服务

#### 实现思路

> 主要功能

- 用户登录注册
- 用户查询
- 修改用户个人资料

#### 部分功能展示

```java
public User queryUser(String username, String password) {
    //1.缓存中查询
    BoundHashOperations<String,Object,Object> hashOperations = this.stringRedisTemplate.boundHashOps(KEY_PREFIX2);
    String userStr = (String) hashOperations.get(username);
    User user;
    if (StringUtils.isEmpty(userStr)){
        //在缓存中没有查到，去数据库查,查到放入缓存当中
        User record = new User();
        record.setUsername(username);
        user = this.userMapper.selectOne(record);
    } else {
        user = JsonUtils.parse(userStr,User.class);
    }
    // 2.校验用户名
    if (user == null){
        return null;
    }
    // 确认存在该用户，才会将该用户放入缓存中
    hashOperations.put(user.getUsername(), JsonUtils.serialize(user));
    // 3. 校验密码
    boolean result = PasswordUtils.passwordConfirm(username + password,user.getPassword());
    if (!result){
        return null;
    }
    //4.用户名密码都正确
    return user;
}
```

## 技术框架说明

### 基础框架或通用逻辑介绍

> 基础功能大多在common服务实现，其他内容也大同小异，所以介绍common服务中的主要内容

1. 提供自定义的异常
2. 提供分页处理的参数以及存储页面信息的pojo
3. 提供自定义的请求响应信息
4. 提供处理cookie、id、json等数据的一些工具

### tk.mybatis:通用mapper使用

> 为什么要用通用mapper

先讲mybatis，通常来说是通过xml文件实现Sql语句，仅仅是简单的增删改查，也需要写大量的代码，而且都是比较重复的。通用mapper在MBG的基础上结合了部分JPA注解，可以简单获取基础单表方法（增删改查），但是多表查询是需要自己写的。

这里又要提一嘴Mybatis Generator了，其通过xml文件配置生成数据库表对应的PO、DAO、XML等文件。但是如果数据库字段变化，就需要重新生成代码，而且MBG覆盖生成代码和追加方式生成XML，导致重新生成时会产生大量的对比修改。

> 如何使用通用mapper

1. 在自己创建的mapper接口中继承tk.mybatis.mapper.common.Mapper接口，即可调用全部功能，接口的实现通过动态代理完成。比如下方UserMapper继承Mapper接口后，即可在UserServiceImpl中调用selectCount方法
   
   ```java
   import com.leyou.user.pojo.User;
   import tk.mybatis.mapper.common.Mapper;
   
   public interface UserMapper extends Mapper<User> {
   }
   ```
   
   ```java
   public Boolean checkData(String data, Integer type) {
       User user = new User();
       switch (type){
           case 1 :
               user.setUsername(data);
               break;
           case 2 :
               user.setPhone(data);
               break;
           default:
               return null;
       }
       return this.userMapper.selectCount(user) == 0;
   }
   ```

2. BaseMapper包含了增删改查方法的基本操作
   
   ```java
   @tk.mybatis.mapper.annotation.RegisterMapper
   public interface BaseMapper<T> extends
           BaseSelectMapper<T>,
           BaseInsertMapper<T>,
           BaseUpdateMapper<T>,
           BaseDeleteMapper<T> {
   
   }
   ```

3. IdsMapper和MysqlMapper包含了批量增删改查的基本方法
   
   ```java
   @tk.mybatis.mapper.annotation.RegisterMapper
   public interface IdsMapper<T> extends SelectByIdsMapper<T>, DeleteByIdsMapper<T> {
   
   }
   ```
   
   ```java
   @tk.mybatis.mapper.annotation.RegisterMapper
   public interface MySqlMapper<T> extends
           InsertListMapper<T>,
           InsertUseGeneratedKeysMapper<T> {
   
   }
   ```

4. ExampleMapper是重点，其继承自MBG，可以实现自定义的查询方法。
   
   ```java
   @tk.mybatis.mapper.annotation.RegisterMapper
   public interface ExampleMapper<T> extends
           SelectByExampleMapper<T>,
           SelectOneByExampleMapper<T>,
           SelectCountByExampleMapper<T>,
           DeleteByExampleMapper<T>,
           UpdateByExampleMapper<T>,
           UpdateByExampleSelectiveMapper<T> {
   
   }
   ```
   
    ​    在以下mapper所实现的方法中，都需要Example对象作为参数，而Example对象包含了我们各种自定义的查询条件，正相当于sql语句中where的部分。如何设置Example对象呢？
   
    ​    一般来说可以先创建Example对象，再创建Example.criteria对象。可以对criteria灵活设置各种条件，实现各种复杂的功能。比方说下图代码就可以查询出所有id比1大的用户
   
   ```java
   @Autowired
       UserMapper userMapper;
   
   @Override
   public List<User> findUserIdGreaterThanOne() {
       // 创建Example实例
       Example example = new Example(User.class);
       // 创建criteria实例
       Example.Criteria criteria = example.createCriteria();
       criteria.andGreaterThan("id", 1);
       example.setOrderByClause("id asc");
       return userMapper.selectByExample(example);
   }
   ```
   

作为国产的mybatis增强工具，逻辑清晰，注释易懂，看起来也挺简单的，用起来也比较方便，支持一下

### eureka-ribbon-zuul-hytrix实现网关

1. eureka内置了ribbon，如果不对负载均衡策略进行重写，将默认采用轮询。相较于nginx，ribbon是运行在服务消费者端的客户端/进程内负载均衡器，而nginx是独立的，请求需要先进入nginx。在本项目中，包括eureka注册中心在内的所有服务都被注册在Eureka Server中
2. 除去eureka自然也需要zuul、hytrix的配合啦！如eureka内置ribbon，zuul内置了hytrix，如果超过一定时间未连接到服务，会将服务剔除注册中心，zuul提供路由功能，将url和微服务进行映射，尤其是设置的图片上传功能带来的一些跨域问题更需要解决。在zuul网关中设置cors跨域配置，通过继承ZuulFilter实现对白名单或者有权限用户的放行，以及对其它请求的拦截。

**过滤的基本逻辑是**：

1. 获取cookie中的token
2. JWT对token进行校验
3. 通过则放行，未通过则重定向到登录页

**路由的基本逻辑是**：

1. 将微服务注册到Eureka中心
2. 对注册的微服务进行路径映射

### 登陆注册服务授权相关问题

#### Spring Security

Spring提供的安全框架

> **项目使用**

BCryptPasswordEncoder()的encode方法进行密码加密，matches方法进行密码验证

#### JWT

JWT全称json Web Token，是目前最流行的跨域认证解决方案，基本思想与token相同。

JWT会生成一个json对象，返回给用户，保存在前端的cookie或者localstorage中，下次访问自动携带该json对象，服务器可以该对象进行用户身份判断，服务器不再需要保存session数据

> **数据结构**

分为三部分，每一部分都是一串很长的字符串，中间用.分隔

- header：头部，存储加密算法
- payload：负载，用来存放用户相关的数据
- signature：签名，header和payload组合到一起，使用加密算法加密后的数据

**header部分是一个json对象组成**，生成jwt的token时会进行BASE64编码，这个不算加密，只是简单的编码

```javascript
{
    "alg": "Hs256"
    "type": "jwt"
}
```

**payload部分也是一个json对象，用来存放实际需要传递的数据。jwt官方规定了7个字段**

- iss：签发人
- exp：过期时间
- sub：主题
- aud：受众
- nbf：生效时间
- jtl：编号

除了官方字段，我们可以自己加入其他字段，比如

```javascript
{
    "username": "admin",
    "age": 21
}
```

这里同样进行base64编码，默认不进行加密，只能存放不太重要或隐私的内容

到这里需要对前两部分进行数字签名

**signature部分就是负责防止数据篡改**

服务器将持有一个加密的秘钥，该秘钥只有服务器知道，并不会返回给用户。然后使用header中指定的算法对数据进行加密。该部分会将payload中的数据，按照header中的加密算法，加上服务器的秘钥，整体进行加密。

> 优点

1. 默认不加密，也可以加密，不容易被客户端篡改
2. 不仅可以用于认证，而且可以用于交换信息

> 缺点

1. 服务器不保存状态，签发令牌不能提前终止，必须等到过期时间
2. 本身包含认证信息，一旦泄露谁都可以使用，所以过期时间不能太长

#### 具体实现

> 总的来说就是token生成解析、rsa加解密的过程

客户端生成token的过程

1. 登录授权，验证用户账户密码是否真实，并检验token是否生成
2. 将token写入cookie，并指定httpOnly为true，这样可以防止js获取或修改

服务端解析token的过程

1. 登录验证，从cookie中获取token信息，并进行解析
2. 如果解析成功刷新token，并更新cookie中token，返回用户信息

有一点需要注意的是zuul可能会去除一些head信息，让cookie无法携带token，可以配置关闭。

### elasticsearch+kibana+ik分词器实现商品搜索

elasticRepositry实现，基本增删改查罢了

### MongoDB实现评论服务

上述两个功能的具体原理留在数据库中讲，项目中用到的其实都是简单的CRUD

### rabbitMq实现数据同步

> 数据同步

当item微服务更新商品有关数据时，页面静态化服务和搜索微服务也需要更新对应的数据；当订单微服务更新订单有关数据时，评论微服务也需要更新相关的数据。这一通知由rabbitMq进行传达，item、订单微服务将通过消息队列给相关服务发送信息

短信微服务平常一般不用，当用户微服务需要用到时候，会通过rabbitMq向短信微服务发送通知，后者接到后会调用发送短信的方法发送验证码

### OpenFeign

> 在Ribbon和RestTemplate基础上，OpenFeign实现更简单的编写Http客户端，包装服务的调用，简化服务间调用流程

使用起来很简单，在api接口@**RequestMapping**注解调用服务对应的路径,这个路径会映射到controller类中，方法上的注解则会映射到对应controller下对应的方法中！在client接口@**FeignClient**注解服务提供方的服务名称，（服务名称在eureka注册中心可以看见）在主启动类注解@**EnableFeignClients**让项目可以通过Feign进行服务调用

```java
@RequestMapping("goods")
public interface GoodsApi {
    @GetMapping("/spu/{id}")
    SpuBo queryGoodsById(@PathVariable("id") Long id);
}
```

```java
@FeignClient(value = "item-service")
public interface GoodsClient extends GoodsApi {
}
```

```java
@SpringBootApplication
@EnableDiscoveryClient
@EnableFeignClients
public class LyCartApplication {

    public static void main(String[] args) {
        SpringApplication.run(LyCartApplication.class,args);
    }
}
```

调用就直接使用client

```java
@Override
public void createIndex(Long id) throws IOException {
    SpuBo spuBo = this.goodsClient.queryGoodsById(id);
    //构建商品
    Goods goods = this.buildGoods(spuBo);

    //保存数据到索引库中
    this.goodsRepository.save(goods);
}
```

### WXpay-微信支付(需要企业认证)

调用微信支付相关接口实现

### 阿里短信服务(需要企业认证)

调用阿里短信服务相关接口实现

### ID生成算法

SnowFlake（雪花算法）：由64bit二进制数字组成，1+41bit-时间戳+10bit-工作机器id+12bit序列号

- **第 0 位**： 符号位（标识正负），始终为 0，没有用，不用管。
- **第 1~41 位** ：一共 41 位，用来表示时间戳，单位是毫秒，可以支撑 2 ^41 毫秒（约 69 年）
- **第 42~52 位** ：一共 10 位，一般来说，前 5 位表示机房 ID，后 5 位表示机器 ID（实际项目中可以根据实际情况调整！在我最近写的项目里，给节点编号为1、1，以此类推的）。这样就可以区分不同集群/机房的节点。
- **第 53~64 位** ：一共 12 位，用来表示序列号。 序列号为自增值，代表单台机器每毫秒能够产生的最大 ID 数(2^12 = 4096),也就是说单台机器每毫秒最多可以生成 4096 个 唯一 ID。

**优点**：生成速度快、生成ID有序递增、比较灵活

**缺点**：如果机器时间不对，和之前一样，可能会产生重复ID（小概率事件）

### Webhook

应用给其他应用提供实时信息的一种方式。信息一产生，webhook就会将它发送给已经注册的应用

### Natapp内网穿透

Spring Bus从Git自动获取更新配置需要设置Webhook，而内网网址直接贴上去是无法访问的的，需要借助内网穿透

> 内网穿透是什么？为什么需要内网穿透？natapp如何实现内网穿透

1. 内网穿透指让本地服务端口在公网也可以访问
2. 因为ip有限，大部分本地网络使用的是运营商下的局域网，不能让公网访问，而项目中需要github自动向eureka发送通知给Spring Bus所在服务，so 需要进行内网穿透
3. natapp提供内网外网的隧道，即提供一个公网服务器，给用户分配一个公网地址和端口号。这个公网服务器就相当于中间人

### 页面静态化处理

商品页面可能受到大量访问，但实际上也不是每个用户都需要实时从数据库中获取当前商品信息，一段时间内的“**准实时**”信息完全够用，所以对于商品页面就进行了页面静态化处理。静态html文件通过thymeleaf等模板引擎对模板进行渲染得到。

**其好处在于：**

1. 提高访问速度，大大提高访问效率
2. 安全性能提高，用户无法从页面获取信息
3. 避免一些因服务端原因导致的一些用户使用问题

### ThreadLocal存储用户信息

用threadlocal存储用户信息的好处在于，用户信息在一次请求中使用，后续就没有继续使用的必要了，threadlocal在请求结束后就可以销毁。并且由于threadlocal只能在线程内使用，也提高了安全性。并

### CountDownLatch、线程池组合实现并发访问

CountDownLatch是在AQS上实现的，其典型的使用方式是将一个程序分为n个互相独立的可解决任务，并创建值为n的CountDownLatch。当每一个任务完成时，都会在这个锁存器上调用countDown，等待问题被解决的任务调用这个锁存器的await，将他们自己拦住，直至锁存器计数结束，大家伙都好聚好散，完成任务。

线程池在这里充当做任务的角色，同时分出n个任务，你得让n个人来做啊，当然也可以加几个备选的候着，有备无患

### 三级分类的实现

在spu表中，我们设计了三级分类的列，分别对应cid1、cid2、cid3。它们对应着category表来进行具体的实现，要对表中的某行进行增删改查，比较类似于对一棵树的某个节点进行增删改查。表中设置了判断自身是否为父节点，以及是否为顶级节点，以及自身父节点是谁的列，所以实现还是比较简单

## 数据库表的设计

首先引出最核心的两个概念spu&sku，出于对系统可扩展性的考量，这两张表要设计的足够易用又抽象。

spu指的是一组具有共同属性的商品集合

sku指的是一个商品集合中因为具体特性不同而细分的产品（比如颜色不同、大小不同抑或一些原因

**随之而来的一个问题**：spu、sku都只能针对一种或一类商品，但是不同的商品是不一样的，需要将一些特有是属性提取出来，通过json格式进行存储，以在一张表内实现存储不同种类商品信息。顺着这个思路来进行数据库表的设计

### spu

SPU表(注意三级分类)：

```mysql
CREATE TABLE `tb_spu` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'spu id',
  `title` varchar(255) NOT NULL DEFAULT '' COMMENT '标题',
  `sub_title` varchar(255) DEFAULT '' COMMENT '子标题',
  `cid1` bigint(20) NOT NULL COMMENT '1级类目id',
  `cid2` bigint(20) NOT NULL COMMENT '2级类目id',
  `cid3` bigint(20) NOT NULL COMMENT '3级类目id',
  `brand_id` bigint(20) NOT NULL COMMENT '商品所属品牌id',
  `saleable` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否上架，0下架，1上架',
  `valid` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否有效，0已删除，1有效',
  `create_time` datetime DEFAULT NULL COMMENT '添加时间',
  `last_update_time` datetime DEFAULT NULL COMMENT '最后修改时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=208 DEFAULT CHARSET=utf8 COMMENT='spu表，该表描述的是一个抽象的商品，比如 iphone8';
```

与我们前面分析的基本类似，但是似乎少了一些字段，比如商品描述。为了不影响主表的查询效率，需要做表的垂直拆分，将SPU的详情放到了另一张表：tb_spu_detail

```mysql
CREATE TABLE `tb_spu_detail` (
  `spu_id` bigint(20) NOT NULL,
  `description` text COMMENT '商品描述信息',
  `specifications` varchar(3000) NOT NULL DEFAULT '' COMMENT '全部规格参数数据',
  `spec_template` varchar(1000) NOT NULL COMMENT '特有规格参数及可选值信息，json格式',
  `packing_list` varchar(1000) DEFAULT '' COMMENT '包装清单',
  `after_service` varchar(1000) DEFAULT '' COMMENT '售后服务',
  PRIMARY KEY (`spu_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

需要注意的是这两个字段：specifications和spec_template。前者是详细的完整的对所有属性都进行了存储，并且对特殊属性的每个特殊选项都进行了展示，而后者则是稍微简化了一些，只保留了一些特殊属性及其相关选项

### sku

SKU表：

```mysql
CREATE TABLE `tb_sku` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'sku id',
  `spu_id` bigint(20) NOT NULL COMMENT 'spu id',
  `title` varchar(255) NOT NULL COMMENT '商品标题',
  `images` varchar(1000) DEFAULT '' COMMENT '商品的图片，多个图片以‘,’分割',
  `price` bigint(15) NOT NULL DEFAULT '0' COMMENT '销售价格，单位为分',
  `indexes` varchar(100) COMMENT '特有规格属性在spu属性模板中的对应下标组合',
  `own_spec` varchar(1000) COMMENT 'sku的特有规格参数，json格式，反序列化时应使用linkedHashMap，保证有序',
  `enable` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否有效，0无效，1有效',
  `create_time` datetime NOT NULL COMMENT '添加时间',
  `last_update_time` datetime NOT NULL COMMENT '最后修改时间',
  PRIMARY KEY (`id`),
  KEY `key_spu_id` (`spu_id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='sku表,该表表示具体的商品实体,如黑色的64GB的iphone 8';
```

这里说下indexes字段，这个是对应了spu表的特有规格，对于每个特殊属性可以做出一些选择，比如0_0_0，表示的是有三个特殊属性，并且都选择了第一个选项。

此外，由于库存字段的写频率较高，而sku的其它字段以读为主，所以单独创建一张库存表（算是一种读写分离）

```mysql
CREATE TABLE `tb_stock` (
  `sku_id` bigint(20) NOT NULL COMMENT '库存对应的商品sku id',
  `seckill_stock` int(9) DEFAULT '0' COMMENT '可秒杀库存',
  `seckill_total` int(9) DEFAULT '0' COMMENT '秒杀总数量',
  `stock` int(9) NOT NULL COMMENT '库存数量',
  PRIMARY KEY (`sku_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='库存表，代表库存，秒杀库存等信息';
```

### 商品相关表

顺着spu和sku发散，spu对应一类商品，所以需要记录多个商品分类，即设置商品分类表(tb_category)，当然商品也有品牌嘛，所以有商品品牌表(tb_order)，当然还有一个中间对应的表(tb_category_brand)

tb_brand表：

```mysql
CREATE TABLE `tb_brand`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '品牌id',
  `name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '品牌名称',
  `image` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '品牌图片地址',
  `letter` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '品牌的首字母',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 325400 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '品牌表，一个品牌下有多个商品（spu），一对多关系' ROW_FORMAT = Dynamic;
```

tb_category表：

```mysql
CREATE TABLE `tb_category`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '类目id',
  `name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '类目名称',
  `parent_id` bigint(20) NOT NULL COMMENT '父类目id,顶级类目填0',
  `is_parent` tinyint(1) NOT NULL COMMENT '是否为父节点，0为否，1为是',
  `sort` int(4) NOT NULL COMMENT '排序指数，越小越靠前',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `key_parent_id`(`parent_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1479 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '商品类目表，类目和商品(spu)是一对多关系，类目与品牌是多对多关系' ROW_FORMAT = Dynamic;
```

tb_category_brand表：

```mysql
CREATE TABLE `tb_category_brand`  (
  `category_id` bigint(20) NOT NULL COMMENT '商品类目id',
  `brand_id` bigint(20) NOT NULL COMMENT '品牌id',
  PRIMARY KEY (`category_id`, `brand_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '商品分类和品牌的中间表，两者是多对多关系' ROW_FORMAT = Dynamic;
```

此外，一类商品应该对应一类规格参数模板（SPU保存有规格参数的具体值哦！），所以需要设置商品规格，这里具体拆分成了两张表，主要是为了搜索服务更加方便。第一张表是规格参数表，详细的描述商品规格的参数；第二张表的规格组表，每个商品分类下有多个分类参数组，使用这张表是为了标记某一规格参数模板对应的是哪一类规格参数（或者说哪一组？

spec_param表：

```mysql
CREATE TABLE `tb_spec_param`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `cid` bigint(20) NOT NULL COMMENT '商品分类id',
  `group_id` bigint(20) NOT NULL,
  `name` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '参数名',
  `numeric` tinyint(1) NOT NULL COMMENT '是否是数字类型参数，true或false',
  `unit` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '数字类型参数的单位，非数字类型可以为空',
  `generic` tinyint(1) NOT NULL COMMENT '是否是sku通用属性，true或false',
  `searching` tinyint(1) NOT NULL COMMENT '是否用于搜索过滤，true或false',
  `segments` varchar(1024) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '数值类型参数，如果需要搜索，则添加分段间隔值，如CPU频率间隔：0.5-1.0',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `key_group`(`group_id`) USING BTREE,
  INDEX `key_category`(`cid`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 33 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '规格参数组下的参数名' ROW_FORMAT = Dynamic;
```

spec_group表：

```mysql
CREATE TABLE `tb_spec_group`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `cid` bigint(20) NOT NULL COMMENT '商品分类id，一个分类下有多个规格组',
  `name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '规格组的名称',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `key_category`(`cid`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 28 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '规格参数的分组表，每个商品分类下有多个规格参数组' ROW_FORMAT = Dynamic;
```

### 订单相关表

这些表比较常规了，订单表、订单细节表、订单状态表，做这些表的拆分的原因是，合在一起一张表太大了

order表：

```mysql
CREATE TABLE `tb_order`  (
  `order_id` bigint(20) NOT NULL COMMENT '订单id',
  `total_pay` bigint(20) NOT NULL COMMENT '总金额，单位为分',
  `actual_pay` bigint(20) NOT NULL COMMENT '实付金额。单位:分。如:20007，表示:200元7分',
  `promotion_ids` varchar(256) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT '',
  `payment_type` tinyint(1) UNSIGNED ZEROFILL NOT NULL COMMENT '支付类型，1、在线支付，2、货到付款',
  `post_fee` bigint(20) NOT NULL COMMENT '邮费。单位:分。如:20007，表示:200元7分',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '订单创建时间',
  `shipping_name` varchar(20) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '物流名称',
  `shipping_code` varchar(20) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '物流单号',
  `user_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL COMMENT '用户id',
  `buyer_message` varchar(128) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '买家留言',
  `buyer_nick` varchar(32) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL COMMENT '买家昵称',
  `buyer_rate` tinyint(1) NULL DEFAULT NULL COMMENT '买家是否已经评价,0未评价，1已评价',
  `receiver_state` varchar(128) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT '' COMMENT '收获地址（省）',
  `receiver_city` varchar(256) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT '' COMMENT '收获地址（市）',
  `receiver_district` varchar(256) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT '' COMMENT '收获地址（区/县）',
  `receiver_address` varchar(256) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT '' COMMENT '收获地址（街道、住址等详细地址）',
  `receiver_mobile` varchar(11) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '收货人手机',
  `receiver_zip` varchar(16) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '收货人邮编',
  `receiver` varchar(32) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '收货人',
  `invoice_type` int(1) NULL DEFAULT 0 COMMENT '发票类型(0无发票1普通发票，2电子发票，3增值税发票)',
  `source_type` int(1) NULL DEFAULT 2 COMMENT '订单来源：1:app端，2：pc端，3：M端，4：微信端，5：手机qq端',
  PRIMARY KEY (`order_id`) USING BTREE,
  INDEX `create_time`(`create_time`) USING BTREE,
  INDEX `buyer_nick`(`buyer_nick`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_bin ROW_FORMAT = Dynamic;
```

order_detail表：

```mysql
CREATE TABLE `tb_order_detail`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '订单详情id ',
  `order_id` bigint(20) NOT NULL COMMENT '订单id',
  `sku_id` bigint(20) NOT NULL COMMENT 'sku商品id',
  `num` int(11) NOT NULL COMMENT '购买数量',
  `title` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '商品标题',
  `own_spec` varchar(1024) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '商品动态属性键值集',
  `price` bigint(20) NOT NULL COMMENT '价格,单位：分',
  `image` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '商品图片',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `key_order_id`(`order_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 218 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '订单详情表' ROW_FORMAT = Dynamic;
```

order_status表：

```mysql
CREATE TABLE `tb_order_status`  (
  `order_id` bigint(20) NOT NULL COMMENT '订单id',
  `status` int(1) NULL DEFAULT NULL COMMENT '状态：1、未付款 2、已付款,未发货 3、已发货,未确认 4、交易成功 5、交易关闭 6、已评价',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '订单创建时间',
  `payment_time` datetime(0) NULL DEFAULT NULL COMMENT '付款时间',
  `consign_time` datetime(0) NULL DEFAULT NULL COMMENT '发货时间',
  `end_time` datetime(0) NULL DEFAULT NULL COMMENT '交易完成时间',
  `close_time` datetime(0) NULL DEFAULT NULL COMMENT '交易关闭时间',
  `comment_time` datetime(0) NULL DEFAULT NULL COMMENT '评价时间',
  PRIMARY KEY (`order_id`) USING BTREE,
  INDEX `status`(`status`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '订单状态表' ROW_FORMAT = Dynamic;
```

此外，还需要记录一下支付记录

pay_log表：

```mysql
CREATE TABLE `tb_pay_log`  (
  `order_id` bigint(20) NOT NULL COMMENT '订单号',
  `total_fee` bigint(20) NULL DEFAULT NULL COMMENT '支付金额（分）',
  `user_id` bigint(20) NULL DEFAULT NULL COMMENT '用户ID',
  `transaction_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '微信交易号码',
  `status` tinyint(1) NULL DEFAULT NULL COMMENT '交易状态，1 未支付, 2已支付, 3 已退款, 4 支付错误, 5 已关闭',
  `pay_type` tinyint(1) NULL DEFAULT NULL COMMENT '支付方式，1 微信支付, 2 货到付款',
  `bank_type` varchar(16) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '银行类型',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `pay_time` datetime(0) NULL DEFAULT NULL COMMENT '支付时间',
  `closed_time` datetime(0) NULL DEFAULT NULL COMMENT '关闭时间',
  `refund_time` datetime(0) NULL DEFAULT NULL COMMENT '退款时间',
  PRIMARY KEY (`order_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;
```

### 用户表

这张表还是经典的

```mysql
CREATE TABLE `tb_user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `username` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '用户名',
  `password` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '密码，加密存储',
  `phone` varchar(11) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '注册手机号',
  `created` datetime(0) NOT NULL COMMENT '创建时间',
  `salt` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '密码加密的salt值',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `username`(`username`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 40 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '用户表' ROW_FORMAT = Dynamic;
```

> 还有一些表，不过也没什么新的设计思路了，列举如下

# 疑项/杂项

## 1.从Git拉取配置看网络的心情

感觉这个问题是有点无解了，也许移到gitee会好一点，但是个人更习惯使用github

## 2.秒杀系统有待进一步升级

1. 采用Redission分布式锁替换原子操作，以提高并发访问效率
2. 消息队列重试策略升级
3. 使用rabbitMq进行流量削峰(可能会降低并发访问效率)
4. 解决秒杀相关安全问题：如黄牛等

## 3.跨域配置

实现跨域配置的主要方案有三种，项目中使用了前两种

1. 负载均衡：nginx代理，非常经典
2. CorsFilter：自定义一个Config调用一下CoresFilter就行
3. @CrossOrigin注解

## 4.微信支付和阿里短信需要企业认证才能申请

awww！！！无能为力，选择从网上用别人的，crazy

## 5.订单支付部分有待进一步升级